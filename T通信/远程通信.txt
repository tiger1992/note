
1、负责域名解析的DNS服务器

  1)、DNS(Domain Name System)：和HTTP协议一样位于应用层协议，主要提供域名到IP的解析服务。
  
2、加速静态资源的访问速度CDN

  1)、CDN(Content Delivery Network)：内容分发网络，其实是一种网络缓存技术，把一些相对稳定得资源放到距离用户较近的地方，不仅可以节省整个广域网的带宽消耗，而且可以提升用户访问速度。
  
3、OSI 七层网络模：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层。

4、TCP/IP 四层概念模型：应用层、传输层、网络层、数据链路层。


====== 负载均衡 ======

1、二层负载：Mac地址，VIP(虚拟ip)，每个机器的Mac地址不一样，IP地址相同。

2、三层负载：IP，对外提供VIP，集群中每个机器采用不同的IP地址。

3、四层负载：传输层负载(IP和端口)，修改IP地址或端口地址。

4、七层负载：应用层(请求url)，http请求报文，主机名称来负载。



====== 一个 http 请求的整个流程(从上往下) ======

开始：客户端发起请求(url) -》当应用程序用 tcp传送数据时，数据被送入协议栈中，然后逐个通过每一层直到被当作一串比特流送入网络。

1、传输层(TCP头、HTTP请求报文)：表示当前协议头使用TCP传输协议，类比于选择了哪家快递公司 -》

2、网络层(IP头、TCP头、HTTP请求报文)：增加ip头，ip地址是一个网卡在一个网络中的通信地址，类比填写包裹寄送地址 -》

3、数据链路层(Mac地址、IP头、TCP头、HTTP请求报文)：增加Mac头，数据包要发送的网卡地址，Mac地址是全局唯一，类比填写包裹寄送地址具体的人(手机号码) -》

4、物理层：转换为比特流进行传输。


====== 服务接收端收到数据包以后的处理过程(从下往上) ======

开始：当目的主机收到一个以太网数据帧时，数据就开始从协议栈中由底向上升，同时去掉各层协议加上的报文首部。每层协议都要去检查报文首部中的协议标识，以确定接收数据的上层协议。

1、物理层：接收到发过来的比特流，看看是否需要请进来坐坐。

2、数据链路层：拿到数据后，从数据中摘到第二层的头，检查Mac地址和当前网卡的Mac是否匹配，如果匹配说明当前消息是发给自己的

3、网络层：拿到IP头，判断IP地址是否是自己的，如果是就转发，继续交给上层处理

4、传输层：TCP头中会携带端口，将报文交给指定端口进程进行处理


====== TCP/IP协议(可靠的协议) ======

1、建立连接机制：TCP 消息的可靠性首先来自于有效的连接建立

2、三次握手建立连接的各个状态，所谓三次握手是指建立一个 TCP 连接时需要客户端和服务器端总共发送三个包以确认连接的建立。在socket编程中，这一过程由客户端执行connect来触发
  
  2)、第一次握手：客户端设置标志位【SYN=1】，随机值【seq=J】，并将该数据包发送给服务器端，客户端进入状态变 SYN_SENT，等待服务器端确认。
  
  3)、第二次握手：服务器端收到数据包后由标志位【SYN=1】知道客户端请求建立连接，服务器端设置【SYN=1】【ACK=1】【ack=J+1】，服务端产生随机值【seq=K】，并将该数据包发送给客户端以确认连接请求，服务器端进入状态 SYN_RCVD。
  
  4)、第三次握手：客户端收到确认后，检查【ack=J+1】【ACK=1】是否正确，如果正确则将标志位【ACK=1】【ack=K+1】，并将该数据包发送给服务器端，
      服务器端检查【ack=K+1】【ACK=1】，如果正确则连接建立成功，客户端和服务器端进入 ESTABLISHED 状态，完成三次握手。随后客户端与服务器端之间可以开始传输数据了。

3、四次挥手即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。在socket编程中，这一过程由客户端或服务端任一方执行close来触发。

  1)、由于TCP连接是全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。
  
  2)、中断连接端可以是客户端，也可以是服务器端。
  
  3)、第一次挥手：客户端发送一个FIN=M，用来关闭客户端到服务器端的数据传送，客户端进入FIN_WAIT_1状态。意思是说"我客户端没有数据要发给你了"，但是如果你服务器端还有数据没有发送完成，则不必急着关闭连接，可以继续发送数据。
  
  4)、第二次挥手：服务器端收到FIN后，先发送ack=M+1，告诉客户端，你的请求我收到了，但是我还没准备好，请继续你等我的消息。这个时候客户端就进入FIN_WAIT_2 状态，继续等待服务器端的FIN报文。
  
  5)、第三次挥手：当服务器端确定数据已发送完成，则向客户端发送FIN=N报文，告诉客户端，好了，我这边数据发完了，准备好关闭连接了。服务器端进入LAST_ACK状态。
  
  6)、第四次挥手：客户端收到FIN=N报文后，就知道可以关闭连接了，但是他还是不相信网络，怕服务器端不知道要关闭，所以发送ack=N+1后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。服务器端收到ACK后，就知道可以断开连接了。客户端等待了2MSL后依然没有收到回复，则证明服务器端已正常关闭，那好，我客户端也可以关闭连接了。最终完成了四次握手。

4、SYN攻击

5、长连接：发送心跳包维持连接，因为建立和关闭连接是消耗性能


====== UDP/IP协议(不可靠的协议) ======

1、基于广播通信，发出去的消息，不关心你有没有收到。


====== ARP 协议 ======

1、已知目标机器的IP，需要获得目标机器的 mac 地址：发送一个广播消息，这个 ip 是谁的，请来认领，认领 ip 的机器会发送一个 mac 地址的响应。

2、有了这个目标 MAC 地址，数据包在链路上广播，MAC 的网卡才能发现，这个包是给它的。MAC 的网卡把包收进来，然后打开 IP 包，发现 IP 地址也是自己的，再打开 TCP 包，发现端口是自己，也就是 80 端口，而这个时候这台机器上有一个 nginx 是监听 80 端口。于是将请求提交给 nginx，nginx 返回一个网页。然后将网页需要发回请求的机器。然后层层封装，最后到 MAC 层。因为来的时候有源 MAC 地址，返回的时候，源 MAC 就变成了目标 MAC，再返给请求的机器。为了避免每次都用 ARP 请求，机器本地也会进行 ARP 缓存。当然机器会不断地上线下线，IP 也可能会变，所以 ARP 的 MAC 地址缓存过一段时间就会过期。


====== 阻塞/非阻塞IO ======

1、非阻塞IO原理：就是进程空间调用 recvfrom，如果这个时候socket内核缓冲区没有数据的话，就直接返回一个 EWOULDBLOCK 错误，然后应用程序通过不断轮询来检查这个状态状态，看内核是不是有数据过来。

2、I/O 复用模型：我们前面讲的非阻塞仍然需要进程不断的轮询重试。能不能实现当数据可读了以后给程序一个通知呢？所以这里引入了一个 IO 多路复用模型，I/O 多路复用的本质是通过一种机制（系统内核缓冲 I/O 数据），让单个进程可以监视多个文件描述符，一旦某个描述符就绪（一般是读就绪或写就绪），能够通知程序进行相应的读写操作。

3、常见的 IO 多路复用方式有【select/poll、epoll】，都是 Linux API 提供的 IO 复用方式。

  1)、select:进程可以通过把一个或者多个 fd 传递给 select 系统调用，进程会阻塞在 select 操作上，这样 select 可以帮我们检测多个 fd 是否处于就绪状态。打开的 fd 是有限制的，默认是 1024
  
  2)、epoll：epoll 是基于事件驱动方式来代替顺序扫描，因此性能相对来说更高，主要原理是，当被监听的 fd 中，有 fd 就绪时，会告知当前进程具体哪一个 fd 就绪，那么当前进程只需要去从指定的 fd 上读取数据即可。fd是操作系统的最大文件句柄。【由于 epoll 能够通过事件告知应用进程哪个 fd 是可读的，所以我们也称这种 IO 为异步非阻塞 IO，当然它是伪异步的，因为它还需要去把数据从内核同步复制到用户空间中，真正的异步非阻塞，应该是数据已经完全准备好了，我只需要从用户空间读就行】






















































