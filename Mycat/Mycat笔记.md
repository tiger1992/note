# 基本概念

1. 主机/实例

2. 物理数据库/物理表

3. 分片/分片节点

4. 分片键/分片算法

5. 逻辑数据库/逻辑表（Mycat）

   一个逻辑表可以映射到多个节点的一张表（分片表），也可以映射到一个节点的表 （非分片表），也可以映射到一个节点的多张表（单库分表）。

6. 。。。

# 主要作用

1. 实现数据库的读写分离

2. 实现数据库的垂直拆分

3. 实现数据库的水平拆分

# 应用场景

1. 需要进行读写分离的场景

2. 需要进行分库分表的场景

3. 多租户场景

4. 数据统计

5. 需要使用同种方式查询多种数据库的场景

6. HBASE的一种替代方案

# 配置

主要的配置文件 server.xml、schema.xml、rule.xml 和具体的分片配置文件

## server.xml



# 分库分表需要考虑的问题

## 跨库关联查询

解决方案：

> 1. 字段冗余（反范式的设计）
> 2. 数据同步：比如商户系统要查询产品系统的产品表，我们干脆在商户系统创建一 张产品表，通过 ETL、MQ 或者 canal 定时同步产品数据。
> 3. 全局表（广播表）：有一些基础信息表，比如行名行号表、行政区划表，被很多 业务系统用到，如果我们放在核心系统，每个系统都要调接口去查询，这个时候我们可 以在所有的数据库都存储相同的基础数据，各个系统自己维护，保持同步。
> 4. 系统层组装：在不同的数据库节点，各自利用查询条件，把符合条件数据的数据查询出来，然后 在内存中重新组装，返回给客户端。

## 分布式事务

核心思想其实是在预先提交能够成功的情况下，尽量缩短同时提交的时间差，来提 升成功的概率。

## 排序、翻页、函数计算问题

跨节点多库进行查询时，会出现 limit 分页，order by 排序的问题。比如有两个节点， 节点 1 存的是奇数 id=1,3,5,7,9……；节点 2 存的是偶数 id=2,4,6,8,10……

## 分布式全局ID

> 1. UUID（Universally Unique Identifier 通用唯一识别码）：UUID 是主键是最简单的方案，本地生成，性能高，没有网络耗时。但缺点也很明显， 由于 UUID 非常长，会占用大量的存储空间；另外，作为主键建立索引和基于索引进行 查询时都会存在性能问题，在 InnoDB 中，UUID 的无序性会引起数据位置频繁变动，导 致分页。
> 2. 数据库：把序号维护在数据库的一张表中。这张表记录了全局主键的类型、位数、起始值， 当前值。当其他应用需要获得全局 ID 时，先 for update 锁行，取到值+1 后并且更新后 返回。并发性比较差。
> 3. Redis：基于 Redis 的 INT 自增的特性，使用批量的方式降低数据库的写压力，每次获取一 段区间的 ID 号段，用完之后再去数据库获取，可以大大减轻数据库的压力。
> 4. 雪花算法 Snowflake（64bit）：a）使用 41bit 作为毫秒数，可以使用 69 年； b）10bit 作为机器的 ID（5bit 是数据中心，5bit 的机器 ID），支持 1024 个 节点；c）12bit 作为毫秒内的流水号（每个节点在每毫秒可以产生 4096 个 ID）； d）最后还有一个符号位，永远是 0。优点：毫秒数在高位，生成的 ID 整体上按时间趋势递增；不依赖第三方系统，稳定 性和效率较高，理论上 QPS 约为 409.6w/s(1000*2^12)，并且整个分布式系统内不会 产生 ID 碰撞；可根据自身业务灵活分配 bit 位。 不足就在于：强依赖机器时钟，如果时钟回拨，则可能导致生成 ID 重复。

## 数据同步

## 事务（最终一致性）

# 数据库范式

#### 1）第一范式

第一范式（1NF）用来确保每列的原子性，要求每列（或者每个属性值）都是不可再分的最小数据单元（也称为最小的原子单元）。

例如，客人住宿信息表 （姓名, 客人编号, 地址, 客房号, 客房描述, 客房类型, 客房状态, 床位数, 入住人数, 价格）。

其中，“地址”列还可以细分为国家、省、市、区等，甚至有的程序还把“姓名”列也拆分为“姓”和“名”等。如果业务需求中不需要拆分“地址”和“姓名”列，则该数据表符合第一范式，如果需要将“地址”列拆分，则下列写法符合第一范式：

客人住宿信息表（姓名, 客人编号, 国家, 省, 市, 区, 门牌号, 客房号, 客房描述, 客房类型, 客房状态, 床位数, 入住人数, 价格）。

#### 2）第二范式

第二范式（2NF）在第一范式的基础上更进一层，要求表中的每列都和主键相关，即要求实体的唯一性。如果一个表满足第一范式，并且除了主键以外的其他列全部都依赖于该主键，那么该表满足第二范式。

客人住宿信息表中的数据主要用来描述客人住宿信息，所以该表主键为（客人编号，客房号）:

- “姓名”列、“地址”列➡“客人编号”列。
- “客房描述”列、 “客房类型”列、“客房状态”列、“床位数”列、“入住人数”列、“价格”列➡“客房号”列。


其中，“➡”符号代表依赖。以上各列没有全部依赖于主键（客人编号，客房号），只是部分依赖于主键，不符合第二范式。

使用第二范式后，客人住宿信息表可以分解成以下两个表：

- 客人信息表（客人编号，姓名，地址，客房号，入住时间，结账日期，押金，总金额），主键为“客人编号”列，其他列都全部依赖于主键列。
- 客房信息表（客房号，客房描述，客房类型，客房状态，床位数，入住人数，价格），主键为“客房号”列，其他列都全部依赖于主键列。

#### 3）第三范式

第三范式（3NF）在第二范式的基础上更进一层，第三范式是确保每列都和主键列直接相关，而不是间接相关，即限制列的冗余性。如果一个关系满足第二范式，并且除了主键以外的其他列都依赖于主键列，列和列之间不存在相互依赖关系，则满足第三范式。

为了更好的理解第三范式，这里我们需要了解传递依赖。假设A、B 和 C 是关系 R 的三个属性，如果 A➡B 且 B➡C，则从这些函数依赖中，可以得出 A➡C。如上所述，依赖 A➡C 称之为传递依赖。

以第二范式中的客房信息表为例，初看该表时没有问题，满足第三范式，每列都和主键列“客房号”相关，再细看会发现：

- "床位数” 列、“价格”列➡“客房类型”列。
- “客房类型”列➡“客房号”列。
- “床位数”列、“价格”列➡“客房号”列


为了满足第三范式，应该去掉“床位数”列，“价格”列和“客房类型”列，将客房信息表分解为如下两个表。

- 客房表（客房号，客房描述，客房类型编号，客房状态，入住人数）
- 客房类型表（客房类型编号，客房类型名称，床位数，价格）


主键与外键在多表中的重复出现不属于数据冗余，非键字段的重复出现才是数据冗余。在客房表中客房状态存在冗余，需要进行规范化，规范化以后的表如下：

- 客房表（客房号，客房描述，客房类型编号，客房状态编号，入住人数）。
- 客房状态表（客房状态编号，客房状态名称）

# 多数据源/动态数据源的解决方案

查询一般要经过这些流程：DAO——Mapper（ORM）——JDBC驱动——代理——数据库服务

## 客户端 DAO 层

1）aplication.properties 定义多个数据源 2）创建@TargetDataSource 注解和 DataSourceNames 3）创建 DynamicDataSource 继承 AbstractRoutingDataSource 4）多数据源配置类 DynamicDataSourceConfig 5）创建切面类 DataSourceAspect，对添加了@TargetDataSource 注解的 类进行拦截设置数据源，使用 DynamicDataSource.setDataSource 动态设置数 据源。 6）在 启 动 类 上 自 动 装 配 数 据 源 配 置 @Import({DynamicDataSourceConfig.class}) 7）在 实 现 类 SysUserServiceImpl 上 加 上 注 解 ， 如 @TargetDataSource(name = DataSourceNames.SECOND)，调用 8）单元测试类 com.gupaoedu.DynamicDSTests 在 DAO 层实现的优势：不需要依赖 ORM 框架，即使替换了 ORM 框架也不受影响。实现简单（不需要解析 SQL 和路由规则），可以灵活地定制。 缺点：不能复用，不能跨语言。

## ORM 框架层

比如我们用 MyBatis 连接数据库，也可以指定数据源。我们可 以基于 MyBatis 插件的拦截机制（拦截 query 和 update 方法），实现数据源的选择。 例如： Mybatis 分片：可以插件通过设置 Statement 的 Connection，或者使用不同的 SqlSessionFactory 实现。

## 驱动层

不管是MyBatis还是Hibernate，还是Spring的JdbcTemplate，本质上都是对JDBC 的封装，所以第三层就是驱动层。比如 Sharding-JDBC，就是对 JDBC 的对象进行了封 装。JDBC 里面有两个核心对象，一个是 Connection，是一个连接的封装，一个是 DataSource，是对一个数据库的封装。 我们可以自己实现一个 DataSource，在项目中配置多个数据源，这样就可以随心所 欲地切换 datasource 了（Sharding-JDBC 就是这样实现的）。

代理层

Mycat 和 Sharding-Proxy

## 数据库服务



# 数据库优化方案思路

1. 重启：释放资源的最好办法

2. SQL与索引：检查慢sql造成的原因，执行过程

3. 表与存储引擎

   如果 SQL 本身没有什么大问题，我们接着就要检查我们查询的目标，也就是表结构 的设计有没有问题。比如你对于字段类型和长度的选择，或者表结构是不是需要拆分或者合并，不同的表应该选择什么存储引擎，是不是要分区等等。

4. 架构

   表结构也没有问题了，就要上升到数据库服务的层面，从架构层面进行优化。 因为数据都是在磁盘上存储，如果加了索引还是很慢，干脆可以把数据在内存里面缓存起来，这个时候可以部署缓存服务器。查询数据先查缓存，没有再查数据库。这样 既可以减少数据库的压力，有可以提升查询速度。 如果一台数据库服务器承受不了访问压力，可以部署集群做负载均衡。当然这些数据库节点应该有自动同步的机制。 有了主从同步之后，就可以主从复制实现读写分离，让写的服务都访问 master 服务器，读的请求都访问从服务器。 有了读写分离之后，问题并没有完全解决： 1、只有一个 master，写的压力没有得到分摊； 2、所有的节点都存储相同的数据，在一个节点出现存储瓶颈的时候，磁盘不够用了， 其他的节点也一样会遇到这个问题。 所以这个时候我们要用到分布式环境中一个非常重要的手段：分片，每个节点都只存储总体数据的一部分，那这个就是我们今天要讲的分库分表。分片以后，为了提升可 用性，可以再对分片做冗余。

5. 数据库配置

   如果通过架构层面没有解决问题，或者机器虽然配置很高但是性能没有发挥到极致， 还可以优化数据库的配置，比如连接数，缓冲区大小等等。就像美颜相机一样，只是还原了你本来的美。

6. 操作系统

7. 当然咯，因为数据库是安装在操作系统上的，所以操作系统的配置也有优化的空间。 最后最后就是硬件的优化，在单机数据库上当然可以做。 这些所有的手段，成本越来越高，但是最后带来的单位收效却越来越小。 另外还有存储方案的替换，业务流程的优化，这里我们就不讨论了。

8. 

9. 。。。





docker 安装mysql

~~~shell
docker run -itd --name mysql01 -p 3301:3306 -v /my/own/mysql01data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=a9k62c mysql:5.7 --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci
~~~

