# Condition 

1. Condition：多线程协调通信的工具类，可以让某些线程一起等待某个条件（condition），只有满足条件时，线程才会被唤醒
2. condition.await();//阻塞当前线程，释放锁，让其他线程能够去竞争获得锁
3. condition.signal();//唤醒阻塞状态的线程

# CountDownLatch 

使用场景：【凡事涉及到需要指定某个事物在执行之前，要等到前置人物执行完毕之后才执行】

1. 允许一个或多个线程一直等待，直到其他线程的操作执行完毕再执行。从命名可以解读到 countdown 是倒数的意思，类似于我们倒计时的概念。
2. countdownlatch 提供了两个方法，一个是 countDown，一个是 await，countdownlatch 初始化的时候需要传入一个整数，在这个整数倒数到 0 之前，调用了 await 方法的程序都必须要等待，然后通过 countDown 来倒数。
3. 从代码的实现来看，有点类似 join 的功能，但是比 join 更加灵活。CountDownLatch 构造函数会接收一个 int 类型的参数作为计数器的初始值，当调用 CountDownLatch 的countDown 方法时，这个计数器就会减一。通过 await 方法去阻塞去阻塞主流程(主线程)。

# Semaphore 

使用场景：【限流操作】

1. semaphore 也就是我们常说的信号灯，semaphore 可以控制同时访问的线程个数，通过 acquire 获取一个许可，如果没有就等待，通过 release 释放一个许可。

# CyclicBarrier

使用场景：【当存在需要所有的子任务都完成时，才执行主任务】

1. CyclicBarrier：让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续工作。CyclicBarrier 默认的构造方法是 CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程调用 await 方法告诉 CyclicBarrier 当前线程已经到达了屏障，然后当前线程被阻塞。

# 阻塞队列

使用场景：【生产者消费者】，阻塞队列是一个 fifo 的队列，所以对于希望在线程级别需要实现对目标服务的顺序访问的场景中。在 Java8 中，提供了 7 个阻塞队列

1. ArrayBlockingQueue：数组实现的有界阻塞队列, 此队列按照先进先出（FIFO）的原则对元素进行排序。
2. LinkedBlockingQueue：链表实现的有界阻塞队列, 此队列的默认和最大长度为Integer.MAX_VALUE。此队列按照先进先出的原则对元素进行排序。
3. PriorityBlockingQueue：支持优先级排序的无界阻塞队列, 默认情况下元素采取自然顺序升序排列。也可以自定义类实现 compareTo()方法来指定元素排序规则，或者初始化 PriorityBlockingQueue 时，指定构造参数 Comparator 来对元素进行排序。
4. DelayQueue：优先级队列实现的无界阻塞队列。
5. SynchronousQueue：不存储元素的阻塞队列, 每一个 put 操作必须等待一个 take 操作，否则不能继续添加元素。
6. LinkedTransferQueue：链表实现的无界阻塞队列。
7. LinkedBlockingDeque：链表实现的双向阻塞队列。

## 阻塞队列的操作方法 

1. 插入元素操作

   ~~~
   (1)、【add(e)】：添加元素到队列中，如果队列满了，继续插入元素会报错，IllegalStateException。
   
   (2)、【offer(e)】：添加元素到队列，同时会返回元素是否插入成功的状态，如果成功则返回 true。
   
   (3)、【offer(e,time,unit)】：当阻塞队列满了以后继续添加元素，生产者线程会被阻塞指定时间，如果超时，则线程直接退出。
   
   (4)、【put(e)】：当阻队列满了以后，生产者继续通过 put添加元素，队列会一直阻塞生产者线程。
   ~~~

   

2. 删除/获取元素操作

   ~~~
   (1)、【remove()】：当队列为空时，调用 remove 会返回 false，如果元素删除成功，则返回 true。
   
   (2)、【take()】：基于阻塞的方式获取队列中的元素，如果队列为空，则 take 方法会一直阻塞，直到队列中有新的数据可以消费。
   
   (3)、【poll()】：当队列中存在元素，则从队列中取出一个元素，如果队列为空，则直接返回 null。
   
   (4)、【poll(time,unit)】：带超时机制的获取数据，如果队列为空，则会等待指定的时间再去获取元素返回。
   ~~~

   

3. Atomic 原子操作 

# ConcurrentHashMap 

1. 并发安全集合，存在多线程访问的情况下使用的集合工具；另外这种也行【Collections.synchronizedMap();】，将非现场安全转为线程安全。
2. CHM 中是支持并发扩容的，也就是说如果当前的数组需要进行扩容操作，可以由多个线程来共同负责。
3. 扩容是 ConcurrentHashMap 的精华之一，扩容操作的核心在于数据的转移，在单线程环境下数据的转移很简单，无非就是把旧数组中的数据迁移到新的数组。但是这在多线程环境下，在扩容的时候其他线程也可能正在添加元素，这时又触发了扩容怎么办？可能大家想到的第一个解决方案是加互斥锁，把转移过程锁住，虽然是可行的解决方案，但是会带来较大的性能开销。因为互斥锁会导致所有访问临界区的线程陷入到阻塞状态，持有锁的线程耗时越长，其他竞争线程就会一直被阻塞，导致吞吐量较低。而且还可能导致死锁。而 ConcurrentHashMap 并没有直接加锁，而是采用 CAS 实现无锁的并发同步策略，最精华的部分是它可以利用多线程来进行协同扩容。简单来说，它把 Node 数组当作多个线程之间共享的任务队列，然后通过维护一个指针来划分每个线程锁负责的区间，每个线程通过区间逆向遍历来实现扩容，一个已经迁移完的bucket 会被替换为一个 ForwardingNode 节点，标记当前 bucket 已经被其他线程迁移完了。
4. 分而治之，支持多线程同时协助操作，再合并每个线程操作的结果，从而得到最终结果。
















