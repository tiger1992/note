
1、什么是数据结构：数据结构是数据的组织、管理和存储格式，其使用目的是为了高效地访问和修改数据。

2、数据结构：是算法表演的舞台

  1)、线性结构：线性结构是最简单的数据结构，包括数组、链表，以及由它们衍生出来的栈、队列、哈希表。
  
  2)、树：树是相对复杂的数据结构，其中比较有代表性的是二叉树，由它又衍生出了二叉堆之类的数据结构。
  
  3)、图：图是更为复杂的数据结构，因为在图中会呈现出多对多的关联关系。
  
  
====== 数组 array，物理结构 ======

1、定义：有限个相同类型的变量所组成的有序集合，数组中的每一个变量被称为元素。数组是最为简单、最为常用的数据结构。

2、在内存中顺序存储。

3、拥有非常高效的随机访问能力。

4、数组所适合的是读操作多、写操作少的场景。


====== 链表 linked list，物理结构 ======

1、定义：一种在物理上非连续、非顺序的数据结构，由若干节点（node）所组成。单向链表的每一个节点又包含存放数据的变量data和指向下一个节点的指针next。

2、只能一级一级单线联系。

3、链表的每一个节点分布在内存的不同位置，依靠next指针关联起来。这样可以灵活有效地利用零散的碎片空间。

4、

====== 栈 stack，逻辑结构 ======

1、定义：一种线性数据结构，它就像一个放入乒乓球的圆筒容器，栈中的元素只能先入后出（First In Last Out，简称FILO）。最早进入的元素存放的位置叫作栈底（bottom），最后进入的元素存放的位置叫作栈顶（top）。

2、栈这种数据结构既可以用数组来实现，也可以用链表来实现。

3、入栈操作（push）就是把新元素放入栈中，只允许从栈顶一侧放入元素，新元素的位置将会成为新的栈顶。

4、出栈操作（pop）就是把元素从栈中弹出，只有栈顶元素才允许出栈，出栈元素的前一个元素将会成为新的栈顶。


====== 队列 queue ======

1、定义：一种线性数据结构，它的特征和行驶车辆的单行隧道很相似。元素只能先入先出（First In First Out，简称FIFO）。队列的出口端叫作队头（front），队列的入口端叫作队尾（rear）。

2、入队（enqueue）就是把新元素放入队列中，只允许在队尾的位置放入元素，新元素的下一个位置将会成为新的队尾。

3、出队操作（dequeue）就是把元素移出队列，只允许在队头一侧移出元素，出队元素的后一个元素将会成为新的队头。

4、实现：利用数组实现循环队列，不但充分利用了数组的空间，还避免了数组元素整体移动的麻烦。


====== 栈和队列的应用场景 ======

1、栈：

  1)、栈的输出顺序和输入顺序相反，所以栈通常用于对“历史”的回溯，也就是逆流而上追溯“历史”。
  
  2)、实现递归的逻辑，就可以用栈来代替，因为栈可以回溯方法的调用链。
  
  3)、著名的应用场景是面包屑导航，使用户在浏览页面时可以轻松地回溯到上一级或更上一级页面。
  
2、队列：

  1)、队列的输出顺序和输入顺序相同，所以队列通常用于对“历史”的回放，也就是按照“历史”顺序，把“历史”重演一遍。

  2)、在多线程中，争夺公平锁的等待队列，就是按照访问顺序来决定线程在队列中的次序的。

  3)、网络爬虫实现网站抓取时，也是把待抓取的网站URL存入队列中，再按照存入队列的顺序来依次抓取和解析的。
  

====== 散列表 ======

1、定义：散列表也叫哈希表，是存储Key-Value映射的集合。对于某一个Key，散列表可以在接近O(1)的时间内进行读写操作

2、index = HashCode (Key) % Array.length

3、哈希冲突：当插入的Entry越来越多时，不同的Key通过哈希函数获得的下标有可能是相同的。例如002936这个Key对应的数组下标是2；002947这个Key对应的数组下标也是2。

4、解决哈希冲突：

  1)、开放寻址法(ThreadLocal) 
  
  2)、—链表法(HashMap)

5、HashMap数组的每一个元素不仅是一个Entry对象，还是一个链表的头节点。每一个Entry对象通过next指针指向它的下一个Entry节点。当新来的Entry映射到与之冲突的数组位置时，只需要插入到对应的链表中即可

6、衡量HashMap需要进行扩容的条件如下【HashMap.Size >= Capacity×LoadFactor】当前长度：Capacity，负载因子：LoadFactor(0.75f)


====== 树 ======

1、定义：树（tree）是n（n≥0）个节点的有限集。当n=0时，称为空树。在任意一个非空树中，有如下特点

  1)、当n>1时，其余节点可分为m（m>0）个互不相交的有限集，每一个集合本身又是一个树，并称为根的子树


====== 二叉树 ======

1、定义：二叉树（binary tree）是树的一种特殊形式。二叉，顾名思义，这种树的每个节点最多有2个孩子节点。

2、重要作用：查找操作和维持相对顺序

3、二叉树的树形结构使它很适合扮演索引的角色。


====== 二叉查找树（binary search tree） ======

1、二叉树的遍历：

  1)、深度优先遍历：遍历顺序如下
    1.前序遍历：根节点、左子树、右子树
	2.中序遍历：左子树、根节点、右子树
	3.后序遍历：左子树、右子树、根节点
  
  2)、广度优先遍历：
    1.层序遍历：

2、绝大多数可以用递归解决的问题，其实都可以用另一种数据结构来解决，这种数据结构就是栈。因为递归和栈都有回溯的特性

====== 完全二叉树(Complete Binary Tree) ======

1、定义：若设二叉树的深度为h，除第 h 层外，其它各层 (1~h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树

====== 二叉堆，顺序存储 ======

1、二叉堆(特殊的完全二叉树)：常见的堆有二叉堆、左倾堆、斜堆、二项堆、斐波那契堆等等

  1)、最大堆：父节点键值总是大于或等于任何一个子节点的键值
  
  2)、最小堆：父节点键值总是小于任何一个子节点的键值

2、游标特征：父节点下标：parent，左孩子下标：2×parent+1；右孩子下标：2×parent+2

3、基本操作：下面几种操作都基于堆的自我调整，把一个不符合堆性质的完全二叉树，调整成一个堆

  1)、插入节点：在插入数据的时候，每插入的数据都是插入到二叉堆的最后一个位置，可能涉及到节点上浮操作。
  
  2)、上浮节点：
  
  3)、删除节点：在删除节点的时候，每次都是删除根节点，删除之后，将二叉堆最后一个数据填充至根节点，可能涉及节点下沉操作
  
  4)、下沉节点：
  
  5)、构建二叉堆：把一个无序的完全二叉树调整为二叉堆，本质上就是让所有非叶子节点依次下沉。

4、1.二叉堆的核心代码是上述的upAdjust()、downAdjust()函数，在实现时要注意 while循环条件判断时是判断childrenIndex以及在更新父子节点下标的值顺序不可倒置

   2.二叉堆是优先队列的理论基石。理解了二叉堆之后，优先队列就很简单了


















